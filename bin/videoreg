#!/usr/bin/env ruby

require 'rubygems'
require 'ostruct'
require 'optparse'
require 'dante'
require_relative '../lib/videoreg'


def colorize(text, color)
  "\e[#{color}m#{text}\e[0m"
end

def red(text)
  colorize(text, 31)
end

def green(text)
  colorize(text, 32)
end

def blue(text)
  colorize(text, 34)
end

ARGV.options do |parser|
  parser.banner = "Usage: #{File.basename($0)} [options]"
  parser.on('-c', '--config CONFIG', 'Use the specified config') { |s| opt.script = s }
  parser.on('-d', '--device DEVICE', 'Run only the specified device') { |d| opt.device = d }
  parser.on('-e', '--ensure', 'Check the state of the daemon') { opt.action = :ensure }
  parser.on('-H', '--halt DEVICE', 'Halt (suspend) the specified device') { |d| opt.action= :halt; opt.device = d }
  parser.on('-r', '--recover DEVICE', 'Recover the device') { |d| opt.action= :recover; opt.device = d }
  parser.on('-P', '--pid PID', 'Set the PID file for the capture process') { |pid| opt.pid_path = pid }
  parser.on('-l', '--log LOGFILE', 'Set the logfile for daemon') { |log| opt.log_path = log }
  parser.on('-R', '--reset', 'Reset the state (remove lock-files)') { opt.action = :reset }
  parser.on('-k', '--kill', 'Kills the capture processes') { opt.action = :kill }
  parser.on('-v', '--version', 'Show the version') { puts "Videoreg #{Videoreg::VERSION}"; exit }
  parser.on('-h', '--help', 'Show this help message') { puts parser; exit }
  parser.parse!

  if opt.script
    unless File.exists?(opt.script)
      puts "File #{opt.script} does not exist!"
      exit
    end
    load(opt.script)
    res = run(opt.device, opt.action)

    if opt.action == :ensure && res.is_a?(Array)
      res.each do |status|
        puts "Registrar #{blue(status[:device])} status: "
        puts "\t Device exists?:\t [#{status[:device_exists?] ? green("YES") : red("NO")}]"
        puts "\t Process alive?:\t [#{status[:process_alive?] ? green("YES") : red("NO")}]"
      end
    end
  else
    puts parser
  end
end

